## User & Groups
```
# add user to group(s)
useradd -aG (groupName,multiple groups) userName
# show userâ€™s groups
id userName
#
usermod -g groupName userName
```

## apt-get vs apt vs aptitude
[reddit link to a great explanation to the differences of apt-get, apt, and aptitude by username djbon2112](https://www.reddit.com/r/debian/comments/9whj01/whats_the_difference_between_apt_aptitude_aptget/e9knpx2/)
So no one here has really given a solid breakdown of the Debian packaging system. This isn't really necessary to answer your question, but I hope it will help clarify why the commands are the way they are, and I've had an inking to write this for a while.

The .deb packaging format is the basic unit here, analogous to .rpm files. Packages come in two types, source and binary, but for simplicity I'm not going to touch on source packages. Binary packages are ar archives that contain 2 subarchives, control.tar.gz and data.tar.XX (usually xz nowadays), as well as a debian-binary file containing the package version. control.tar.gz contains, as it says, control files: conffiles lists configuration files, control lists the package information for dpkg to use, including dependencies and recommends, md5sums a list of file MD5 sums to verify files, and the postinst/postrm/preinst/prerm scripts that are executed when they sound like, which do things like create users, set up file ownership, start daemons, etc., and the inverse on removal. data.tar.XX contains a relative virtual filesystem starting from /, and containing the literal files that the package installs on the system, including the binaries, docs, config files/templates, and anything else. This is a big reason why you shouldn't be mucking about in places like /usr/bin or /lib, because dpkg ultimately manages all of these files for you.

With the package format out of the way, we get to the lowest level user-accessible tool, dpkg. It works mostly like the rpm command in a practical sense, in that it takes a single .deb archive and installs it. dpkg keeps track of the installed packages in its database under /var/lib/dpkg, which also includes all the control.tar.gz files mentioned above (under info/), as well as a massive concatenation of all the control text files (in available). This directory is really the heart of dpkg's knowledge of your system: any package you install is listed in here, along with all its control files, and this is the database that the dpkg too uses to know what you have installed. Managing the installed packages on your system is all it does: you give it that single .deb file, and, assuming all dependencies are satisfied, it will unarchive the control.tar.gz archive, add the control file to its database, execute the preinst script, extract the data.tar.XX file against /, then execute the postinst script. Voila, your package is installed. Removal happens in the reverse order but with a lot of rm, since the control files list what files are present in each package, and config files listed in conffiles are left alone by default (that's what purge does with apt-get/apt). dpkg only ever knows about packages that are actually installed, and you can for instance list installed packages with it (dpkg -l), or query the installed database in other more advanced ways. But for the most part, unless you're downloading an omnibus .deb, you never need to worry about dpkg.

So dpkg is really low-level, so someone wrote the first layer of abstraction: apt-get, and it's cousin apt-cache. apt-get's job is to scan repository mirrors, sort out dependency trees (by looking in the control files), download files, and install them in a correct and sensible order with dpkg. Another poster derisively called it a "wrapper", which isn't really true: dpkg has no knowledge of repositories, downloading, or anything else; this is all apt-get's domain. Running its commands like update, install, and remove all trigger calls to dpkg eventually to actually do the grunt work of setting up the packages, but the command does a lot of its own stuff to handle dependencies, downloading over various protocols, and caching remote archive information for local use.

apt-cache is a cousin command that is used for querying information about the repositories via the locally cached copies fetched with apt-get update. This includes searching for packages, displaying information, etc. about packages that aren't yet installed. For most novices this was always a relatively rare command outside of searching but was useful for querying potential changes and showing package information.

apt-file is another optional part of the toolstack which is really useful for searching packages for individual files, for instance "what package has /usr/bin/foobar". I highly recommend it if you ever ask that question!

Finally in the "original APT toolstack", apt-key manages repository signing keys, which ensure cryptographic verification of any files you download via APT to protect against corruption and spoofing. In theory and (AFAIK) practice, they make sure you're downloading trusted packages from the people who gave you the keys (the Debian project master keys for the official repos, or a repo owner for a third-party APT repo).

Now it's worth stressing that these 3 tools are OLD. All of them have existed for 20 or more years (APT from 1998, dpkg from 1994), and that age should tell you a lot about the era they were designed in. Though they've all grown over the years, fundamentally they're the same as they always have been, and can show their age in a lot of ways (like having multiple commands to interface with the APT system...). And I'd be remiss if I didn't mention the precursor to them, dselect, which was the original "package manager" written alongside dpkg back in 1994.

apt is a newer, more functional, rewrite of the apt-get/apt-cache toolstack which aims to provide a single unified, modern, and "pretty" CLI command for interfacing with APT. It can do (as of at least Debian 9, as far as I can tell) everything those other commands do for 99.9% of administrative tasks. Personally I've jumped right in the front of this bandwagon, since I find the output far nicer and more unified. But fundamentally apt is the replacement for the other two going forward; just don't expect them to be deprecated any time soon.

Finally aptitude is an ncurses GUI tool (with CLI commands) that works as an alternative to apt-get, originally released in 1999 as an alternative to apt-get and friends. It has a slightly different dependency parsing system, including a very lovely multiple-choice dependency resolution option which is useful sometimes. But from a basic level it does the same thing as apt-get/apt-cache and apt, just in a GUI format. Similarly, synaptic is the official desktop environment GUI tool to fit a similar niche.

That ended up being ridiculously long, but I hope this helps either you or another passer-through better understand the Debian package system, how it works, and why it is how it is.
